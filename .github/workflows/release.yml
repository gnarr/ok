name: Release and Build

on:
  push:
    branches: [ main ]

permissions:
  contents: write
  packages: write

env:
  CARGO_TERM_COLOR: always
  CARGO_RELEASE_VERSION: "0.25.16"
  GIT_CLIFF_VERSION: "2.8.0"

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version_info.outputs.new_version }}
      release_needed: ${{ steps.version_info.outputs.release_needed }}
      rustc_version: ${{ steps.version_info.outputs.rustc_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate sanitized Cargo.lock
        run: |
          cp Cargo.lock Cargo-sanitized.lock
          sed -i '/name = "ok"/{n;/version =/d}' Cargo-sanitized.lock

      - name: Cargo cache
        uses: actions/cache@v4
        id: cache-cargo
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo-sanitized.lock') }}

      - name: Remove sanitized Cargo.lock
        run: rm Cargo-sanitized.lock

      - name: Install cargo-release and git-cliff
        if: steps.cache-cargo.outputs.cache-hit != 'true'
        run: |
          cargo install cargo-release --version ${{ env.CARGO_RELEASE_VERSION }} --locked
          cargo install git-cliff --version ${{ env.GIT_CLIFF_VERSION }} --locked

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine next version
        id: version_info
        shell: bash
        run: |
          set -eo pipefail
          rustc_version=$(rustc -V | tr ' ' '_' || echo "rustc_unknown")
          current_version=$(grep '^version\s*=' Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          commits_since_tag=0
          if [ -n "$latest_tag" ]; then
            commits_since_tag=$(git rev-list --count "${latest_tag}..HEAD")
          fi
          bump_patch() {
            IFS='.' read -r major minor patch <<<"$1"
            echo "${major}.${minor}.$((patch+1))"
          }
          candidate="$current_version"
          if [ "$latest_tag" = "v$current_version" ]; then
            candidate=$(bump_patch "$candidate")
          fi
          while git rev-parse -q --verify "refs/tags/v${candidate}" >/dev/null; do
            candidate=$(bump_patch "$candidate")
          done
          release_needed=true
          if [ "$latest_tag" = "v$current_version" ] && [ "$commits_since_tag" -eq 0 ]; then
            release_needed=false
          fi
          echo "current_version=$current_version"
          echo "latest_tag=$latest_tag"
          echo "rustc_version=$rustc_version"
          echo "new_version=$candidate" >> $GITHUB_OUTPUT
          echo "release_needed=$release_needed" >> $GITHUB_OUTPUT

      - name: Generate changelog
        if: steps.version_info.outputs.release_needed == 'true'
        run: |
          git cliff --output RELEASE.md --unreleased --tag v${{ steps.version_info.outputs.new_version }}
          git cliff --output CHANGELOG.md --tag v${{ steps.version_info.outputs.new_version }}

      - name: Set crate version to new version
        if: steps.version_info.outputs.release_needed == 'true'
        run: cargo set-version ${{ steps.version_info.outputs.new_version }}

      - name: Stage changelog
        if: steps.version_info.outputs.release_needed == 'true'
        run: git add CHANGELOG.md

      - name: Commit changelog
        if: steps.version_info.outputs.release_needed == 'true'
        run: |
          git commit -m "chore: update changelog for v${{ steps.version_info.outputs.new_version }}" || echo "No changes to commit"

      - name: Run cargo release
        if: steps.version_info.outputs.release_needed == 'true'
        run: |
          cargo release ${{ steps.version_info.outputs.new_version }} \
            --no-publish \
            --no-confirm \
            --execute

      - name: Push changes
        if: steps.version_info.outputs.release_needed == 'true'
        run: git push --follow-tags origin main

      - name: Create GitHub Release
        if: steps.version_info.outputs.release_needed == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version_info.outputs.new_version }}
          body_path: RELEASE.md
          name: Release v${{ steps.version_info.outputs.new_version }}
          token: ${{ secrets.RELEASE_PAT }}

  linux-build:
    needs: release
    if: needs.release.outputs.release_needed == 'true'
    runs-on: ubuntu-latest
    strategy:
        fail-fast: false
        matrix:
          include:
            - target: x86_64-unknown-linux-gnu
              artifact_suffix: linux-amd64
              use_cross: false
            - target: aarch64-unknown-linux-gnu
              artifact_suffix: linux-arm64
              use_cross: true
            - target: armv7-unknown-linux-gnueabihf
              artifact_suffix: linux-armv7
              use_cross: true
    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.release.outputs.new_version }}
          fetch-depth: 1
      - name: Cargo cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ matrix.target }}-${{ needs.release.outputs.rustc_version }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.target }}-${{ needs.release.outputs.rustc_version }}-
            ${{ runner.os }}-cargo-${{ matrix.target }}-
            ${{ runner.os }}-cargo-${{ needs.release.outputs.rustc_version }}-
            ${{ runner.os }}-cargo-
      - name: Install sccache
        run: |
          if ! command -v sccache >/dev/null 2>&1; then
            cargo install sccache --locked
          fi
        shell: bash
      - name: Configure sccache
        run: |
          echo "RUSTC_WRAPPER=$(which sccache)" >> $GITHUB_ENV
          echo "SCCACHE_DIR=$HOME/.cache/sccache" >> $GITHUB_ENV
        shell: bash
      - name: Install cross
        if: matrix.use_cross
        run: cargo install cross --locked
      - name: Build
        run: |
          if [ "${{ matrix.use_cross }}" = "true" ]; then
            cross build --release --target ${{ matrix.target }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi
      - name: Extract name
        id: pkg
        run: |
          echo "project_name=$(grep '^name =' Cargo.toml | cut -d '\"' -f2)" >> $GITHUB_OUTPUT
      - name: Prepare artifact
        run: |
          mkdir -p release
          cp target/${{ matrix.target }}/release/${{ steps.pkg.outputs.project_name }} release/${{ steps.pkg.outputs.project_name }}-${{ matrix.artifact_suffix }}
      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_suffix }}
          path: release/*
          retention-days: 1
      - name: Upload Binary Artifact to GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: gh release upload "v${{ needs.release.outputs.new_version }}" "release/${{ steps.pkg.outputs.project_name }}-${{ matrix.artifact_suffix }}" --clobber

  windows-amd64:
    needs: release
    if: needs.release.outputs.release_needed == 'true'
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.release.outputs.new_version }}
          fetch-depth: 1
      - name: Cargo cache
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\cargo\bin\
            ~\AppData\Local\cargo\registry\index\
            ~\AppData\Local\cargo\registry\cache\
            ~\AppData\Local\cargo\git\db\
            target\
          key: ${{ runner.os }}-cargo-windows-${{ needs.release.outputs.rustc_version }}-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-windows-${{ needs.release.outputs.rustc_version }}-
            ${{ runner.os }}-cargo-windows-
      - run: cargo build --release
      - name: Extract name
        id: pkg
        shell: pwsh
        run: |
          $line = Select-String -Path Cargo.toml -Pattern '^name\s*='
          if (-not $line) { Throw 'Cannot find package name in Cargo.toml' }
          $n = $line.Line -replace '.*=\s*"(.*)".*','$1'
          "project_name=$n" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
      - name: Copy Windows binary
        shell: pwsh
        run: |
          mkdir -Force release
          cp "target/release/${{ steps.pkg.outputs.project_name }}.exe" `
              "release/${{ steps.pkg.outputs.project_name }}-windows-amd64.exe"
      - uses: actions/upload-artifact@v4
        with: { name: windows-amd64, path: release/*, retention-days: 1 }
      - name: Upload Binary Artifact to GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: gh release upload "v${{ needs.release.outputs.new_version }}" "release/${{ steps.pkg.outputs.project_name }}-windows-amd64.exe" --clobber
    outputs:
      project_name: ${{ steps.pkg.outputs.project_name }}

  apple-arm64:
    needs: release
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.release.outputs.new_version }}
          fetch-depth: 0
      - run: cargo install cross --locked
      - run: cross build --release --target aarch64-apple-darwin
      - name: Extract name
        id: pkg
        run: |
          echo "project_name=$(grep '^name =' Cargo.toml | cut -d '"' -f2)" >> $GITHUB_OUTPUT
      - run: |
          mkdir -p release
          cp target/aarch64-apple-darwin/release/${{ steps.pkg.outputs.project_name }} release/${{ steps.pkg.outputs.project_name }}-darwin-arm64
      - uses: actions/upload-artifact@v4
        with: { name: darwin-arm64, path: release/*, retention-days: 1 }
      - name: Upload Binary Artifact to GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: gh release upload "v${{ needs.release.outputs.new_version }}" "release/${{ steps.pkg.outputs.project_name }}-darwin-arm64" --clobber
    outputs:
      project_name: ${{ steps.pkg.outputs.project_name }}

  docker_image:
    needs: [release, linux-build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.release.outputs.new_version }}
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with: { path: binaries, pattern: 'linux-*' }
      - run: |
          mkdir -p binaries/linux-{amd64,arm64,arm-v7}
          mv binaries/linux-amd64/ok-linux-amd64    binaries/linux-amd64/ok_server
          mv binaries/linux-arm64/ok-linux-arm64    binaries/linux-arm64/ok_server
          mv binaries/linux-armv7/ok-linux-armv7    binaries/linux-arm-v7/ok_server
      - uses: docker/setup-qemu-action@v2
      - uses: docker/setup-buildx-action@v2
      - uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}
      - uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64,linux/arm/v7
          push: true
          tags: |
            gnarr/ok:v${{ needs.release.outputs.new_version }}
            gnarr/ok:latest
          build-args: |
            BINARY_NAME=ok_server
      - name: Update DockerHub README
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          repository: gnarr/ok
          short-description: ${{ github.event.repository.description }}
          readme-filepath: ./README.md
      
